[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index 2.html",
    "href": "index 2.html",
    "title": "Homework 2 - Scrapy",
    "section": "",
    "text": "Introduction\nhttps://andrewshan214.github.io/PIC16B/posts/Homework%20#2%20-%20Scrapy/index.ipynb\nIn this blog post, I will be giving a tutorial on how to write a spider in scrapy to scrape information from a movie database. More specifically, I will be demonstrating using Christopher Nolan’s “The Dark Knight”, one of my favorite movies. Using the data that I scrape, I will create a chart to suggest movies based on the actors in “The Dark Knight”.\n\n\nWriting the movie database parse() function\nFirst we write the initial parse() function, shown below:\n\ndef parse(self, response):\n        cast_crew_url = f\"https://www.themoviedb.org/movie/155-the-dark-knight/cast\"\n        yield scrapy.Request(cast_crew_url, callback=self.parse_full_credits)\n\nThis method works by saving the url of the full cast and crew page of the movie website. I use scrapy’s built in functions to go into this website and call a second parse function that will save all of the nanmes of those that acted in the movie. The implementation of the second parse function is below.\n\n\nparse_full_credits function implementation\n\ndef parse_full_credits(self, response):\n        for cast_member in response.css(\"ol.people.credits li\"):\n            actor_url = cast_member.css('a::attr(href)').get()\n\n            if actor_url:\n                yield scrapy.Request(url=response.urljoin(actor_url), callback=self.parse_actor_page)\n\nFirstly, I iterated through all of the actors by using the css identifier of only actors by looking at the html code in the movie cast website. While iterating, I saved each actor’s unique page url in a variable. Using that url variable, I used Scrapy’s request function to go into the actor’s page.\nIn this page, I called a third parse function.\n\n\nparse_actor_page function implementation\n\ndef parse_actor_page(self, response):\n        actor_name = response.css('div.title h2.title a::text').get()\n\n        acting_roles = response.css('div.credits_list h3.zero:contains(\"Acting\")')\n        \n        if acting_roles:\n            for acting_role in acting_roles.xpath('./following-sibling::table[@class=\"card credits\"]//table[@class=\"credit_group\"]'):\n                movie_name = acting_role.css('td.role a.tooltip bdi::text').get()\n\n                if movie_name:\n                    yield {\n                        'actor': actor_name,\n                        'movie_or_TV_name': movie_name,\n                    }\n\nI implemented this by first getting the actor’s name by using the css identifier from the website.\nNext, I sorted through only this actor’s acting roles by using the css identifier for acting roles, which was “Zero”. I iterated through all of these acting roles, and got each movie name, and yielded them into a dictionary of the actor’s name and the movies they’ve acted in."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Hello classmates! I’m a third year Mathematics/Economics Major, with a specialization in Computing.\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/Palmer Penguins/index.html",
    "href": "posts/Palmer Penguins/index.html",
    "title": "Palmer Penguins Tutorial",
    "section": "",
    "text": "Blog Post URL https://andrewshan214.github.io/PIC16B/posts/Palmer%20Penguins/\nIn this blog post, I will be giving a short tutorial on how to make a simple data visualization of the “Palmer Penguins” data set. More specifically, I will be showing a simple and informative visualization as a scatter plot to visualize the relationship between penguin culmen length and culmen depth.\nFirst, we load the necessary packages and data, as shown below.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\ndata = \"/Users/andrewhan/PIC16B/posts/Palmer Penguins/palmer_penguins.csv\"\npenguins = pd.read_csv(data)\n\nNext, we will filter our data set to drop any entries with NaN values for their culmen length and/or depth.\nUsing that filtered data, we will group the data based on those categories. Then we will plot the data using the matplotlib package. Using key words, we can choose the type of chart we want, as well as the colors. In this case, I went with a scatter plot with blue dots.\nAfter adding the titles and labels, we can display our data visualization!\n\npenguins_filtered = penguins.dropna(subset = ['Culmen Length (mm)', 'Culmen Depth (mm)'])\n\nplt.figure(figsize=(10, 6))\nplt.scatter(penguins['Culmen Length (mm)'], penguins['Culmen Depth (mm)'], c='blue', alpha=0.7)\nplt.title('Scatter Plot of Culmen Length vs Culmen Depth')\nplt.xlabel('Culmen Length (mm)')\nplt.ylabel('Culmen Depth (mm)')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nAs we can see, there is scatter plot with all of our data points (penguins) plotted with their respective culmen length and depth. It seems that there is no identifiable trend between their length and depth measurements as there are many penguins with both proportionally larger culmen lengths and culmen depths."
  },
  {
    "objectID": "posts/Homework3-Message_Bank/index.html",
    "href": "posts/Homework3-Message_Bank/index.html",
    "title": "Message bank Tutorial",
    "section": "",
    "text": "Introduction\nThe url for this blog is: https://andrewshan214.github.io/PIC16B/\nThe url for the github repo is: https://github.com/andrewshan214/PIC16B\nIn this blog post, I will be giving a short tutorial on how to make a simple message bank using Python’s Flask library, as well as incorporating HTML and CSS files to develop a webpage\nFirst, we create the necessary files. To start we will create our app.py file, which will be a Python script file that will be running the Flask library tasks. Please see below.\n\nfrom flask import Flask, render_template, request\nfrom flask import redirect, url_for, abort\nfrom flask import g\nimport sqlite3\n\napp = Flask(__name__)\n\n\n\nGoing through app.py file\nAlong with importing the necessary libraries, we must define a few functions and databases for our message bank. Please see the comments above each function to understand what each function is doing in the context of the webpage.\n\n# Create a sqlite3 database to handle all of the submitted messages\nDATABASE = 'messages_db.sqlite'\n\n# This function checks for the existence of a message_db in the global 'g' object. It then closes the database connection if it sees its existence.\n@app.teardown_appcontext\ndef close_db(error):\n    if hasattr(g, 'message_db'):\n        g.message_db.close()\n\n@app.route('/') # @app.route essentially tells the code what the end of the url of this particular page would be. \n# Because this is the base 'Home' page, we use a simple '/' to conclude the url.\ndef base():\n    #Uses Flask's render_template function to render the base.html file\n    return render_template('base.html')\n\n\n\nConnection between app.py and each page’s html file.\nAfter defining a base() function, we must accompany it with an html file to tell the website what to display on this page. See below for the code for base.html.\n\n&lt;!doctype html&gt;\n&lt;link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\"&gt;\n&lt;title&gt;{% block title %}{% endblock %} - PIC16B Website&lt;/title&gt;\n&lt;nav&gt;\n    &lt;h1&gt;PIC16B Message Bank!&lt;/h1&gt;\n    &lt;ul&gt;\n        &lt;li&gt;&lt;a href=\"{{ url_for('base') }}\"&gt;Main page&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=\"{{ url_for('submit_message')}}\"&gt;Submit Message&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=\"{{ url_for('render_view_template') }}\"&gt;View Messages&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n&lt;nav&gt;\n&lt;section class=\"content\"&gt;\n    &lt;header&gt;\n    {% block header %}{% endblock %}\n    &lt;/header&gt;\n    {% block content %}{% endblock %}\n&lt;/section&gt;\n\n\n\nbase.html\nWhat this code is doing is both serving as a base for additional html files, as well as formatting the base page. It lays out a page title, as well as navigation functionality to visit other pages. See below for the app.py function that renders the message submission page, as well as the accompanying submit.html file.\n\n# Like before, we use @app.route. \n#However, now we must define the methods to ensure that user submission is possible by adding methods=['GET, POST']\n\n@app.route('/submit/', methods=['GET', 'POST'])\ndef submit_message():\n    #different methods for diff request methods\n    if request.method == 'GET':\n        #if 'GET' just render the template\n        return render_template('submit.html')\n    \n    else:\n        try:\n            handle, message = insert_message(request)\n            #render the template with a thank you note\n            return render_template('submit.html', thank_you = True, message = message, handle = handle)\n        except:\n            return render_template('submit.html', error=True)\n\n\n{% extends \"base.html\" %} \n\n{% block header %}\n  &lt;h1&gt;{% block title %}Submit Message{% endblock %}&lt;/h1&gt;\n{% endblock %}\n\n{% block content %}\n    &lt;form action=\"/submit\" method=\"post\"&gt;\n        &lt;label for=\"message\"&gt;Message:&lt;/label&gt;&lt;br&gt;\n        &lt;input type=\"text\" id=\"message\" name=\"message\"&gt;&lt;br&gt;\n        &lt;label for=\"name\"&gt;Name:&lt;/label&gt;&lt;br&gt;\n        &lt;input type=\"text\" id=\"name\" name=\"name\"&gt;&lt;br&gt;\n        &lt;input type=\"submit\" value=\"Submit\"&gt;\n    &lt;/form&gt;\n{% endblock %}\n\n\n\nMessage Submission Page\nThis page is run by the function submit_message(), which essentially receives a message from the user and renders the submit.html page. The submit.html file “extends” the base.html file, which essentially means that many components, like the style.css, is automatically transferred from the base.html file to submit.html. See below for a screenshot of this page.\n\n\n\nMessageSubmission\n\n\n\n\nDatabase Management\nSee below for the code for inserting a message into the SQL message database.\n\n@app.route('/getmsg/', methods=['GET'])\ndef get_message_db():\n\n    #try to retrieve database connection from global g object\n    try:\n        db = g.message_db\n    except AttributeError:\n        db = g.message_db = sqlite3.connect(DATABASE)\n        db.execute('''\n            CREATE TABLE IF NOT EXISTS messages (\n                id INTEGER PRIMARY KEY,\n                handle TEXT,\n                message TEXT\n            )\n        ''')\n    return db\n\n@app.route('/insert_msg/', methods=['POST'])\ndef insert_message(request):\n    # get message and handle from request\n    try:\n        message = request.form['message']\n        handle = request.form['name']\n\n        db = get_message_db()\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO messages (handle, message) VALUES (?, ?)\", (handle, message))\n        db.commit()\n\n        return redirect('/submit/')\n    except Exception as e:\n        return render_template('submit.html', error=True)\n\n\n\ninsert_message(request)\nWhat this function does is connect to the message database and inserts the user-inputted message into the database so that it can be displayed in the message viewing page.\nSee below for how the message viewing page is run.\n\n\nRandom Messages Page\n\n@app.route('/random_messages/&lt;int:n&gt;')\ndef random_message(n):\n    db = get_message_db()\n    cursor = db.cursor()\n    cursor.execute(\"SELECT * FROM messages ORDER BY RANDOM() LIMIT ?\", (n,))\n    messages = cursor.fetchall()\n    return render_template('view.html', messages=messages)\n\n\n@app.route('/random_messages/')\ndef render_view_template():\n    messages = random_message(5)\n\n    return render_template('view.html', messages = messages)\n\nThese functions connect to the message database to return and render a list of previously inputted, randomly selected messages to the user. See below for the view.html file.\n\n{% extends \"base.html\" %}\n\n{% block content %}\n    &lt;h2&gt;Random Messages&lt;/h2&gt;\n    &lt;ul&gt;\n        {% for message in messages %}\n            &lt;li&gt;\n                &lt;strong&gt;{{ message.handle }}&lt;/strong&gt; - {{ message.message }}\n            &lt;/li&gt;\n        {% endfor %}\n    &lt;/ul&gt;\n{% endblock %}\n\n\n\nview.html\nThis code also “extends” base.html. This html code is much simpler as it simply lists the previous messages, and doesn’t need to receive any information from the website user. See an example below.\n\n\n\nRandomMessages\n\n\n\n\nstyle.css\nWe have now seen how the website functions on the back-end with the database management and user inputs. However, this must all be presentable. As I mentioned earlier, the base.html file is accompanies by a style.css file. See below for the css code.\n\n/* Import a custom font from Google Fonts */\n@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');\n\n/* Apply the custom font to the entire body */\nbody {\n    font-family: 'Roboto', sans-serif;\n    background-color: #f0f0f0; /* Light gray background */\n    color: #333; /* Dark gray text */\n}\n\n/* Style the navigation bar */\nnav {\n    background-color: #333; /* Dark background color */\n    color: white; /* White text */\n    padding: 10px;\n}\n\n/* Style navigation links */\nnav a {\n    color: white; /* White text */\n    text-decoration: none; /* Remove underline */\n    margin-right: 10px; /* Add some margin between links */\n}\n\n/* Style the header section */\nheader {\n    background-color: #007bff; /* Blue background color */\n    color: white; /* White text */\n    padding: 20px;\n    text-align: center; /* Center align text */\n}\n\n/* Add some margin around the content */\n.content {\n    margin: 20px;\n}\n\n/* Style forms */\nform {\n    margin-bottom: 20px; /* Add margin below forms */\n}\n\n/* Style text inputs and buttons */\ninput[type=\"text\"], button {\n    padding: 10px;\n    margin-right: 10px;\n}\n\n/* Style buttons */\nbutton {\n    background-color: #007bff; /* Blue background color */\n    color: white; /* White text */\n    border: none; /* Remove border */\n    cursor: pointer; /* Change cursor to pointer */\n}\n\n/* Change button color on hover */\nbutton:hover {\n    background-color: #0056b3; /* Darker blue on hover */\n}\n\n/* Style unordered lists */\nul {\n    list-style-type: none; /* Remove bullet points */\n    padding: 0; /* Remove default padding */\n}\n\n/* Add some margin below list items */\nli {\n    margin-bottom: 10px;\n}\n\nThis code goes through many different customizations, such as font type, font size and color, page color, etc.\n\n\nConclusion\nAs we can see, there are many different things to account for in web development. Hopefully, this blog post was informational and helpful in developing your next webpage. Thank you!\n\nAndrew Han"
  },
  {
    "objectID": "posts/Homework #2 - Scrapy/index.html",
    "href": "posts/Homework #2 - Scrapy/index.html",
    "title": "Homework 2 - Scrapy",
    "section": "",
    "text": "Introduction\nhttps://andrewshan214.github.io/PIC16B/posts/Homework%20#2%20-%20Scrapy/index.ipynb\nIn this blog post, I will be giving a tutorial on how to write a spider in scrapy to scrape information from a movie database. More specifically, I will be demonstrating using Christopher Nolan’s “The Dark Knight”, one of my favorite movies. Using the data that I scrape, I will create a chart to suggest movies based on the actors in “The Dark Knight”.\n\n\nWriting the movie database parse() function\nFirst we write the initial parse() function, shown below:\n\ndef parse(self, response):\n        cast_crew_url = f\"https://www.themoviedb.org/movie/155-the-dark-knight/cast\"\n        yield scrapy.Request(cast_crew_url, callback=self.parse_full_credits)\n\nThis method works by saving the url of the full cast and crew page of the movie website. I use scrapy’s built in functions to go into this website and call a second parse function that will save all of the nanmes of those that acted in the movie. The implementation of the second parse function is below.\n\n\nparse_full_credits function implementation\n\ndef parse_full_credits(self, response):\n        for cast_member in response.css(\"ol.people.credits li\"):\n            actor_url = cast_member.css('a::attr(href)').get()\n\n            if actor_url:\n                yield scrapy.Request(url=response.urljoin(actor_url), callback=self.parse_actor_page)\n\nFirstly, I iterated through all of the actors by using the css identifier of only actors by looking at the html code in the movie cast website. While iterating, I saved each actor’s unique page url in a variable. Using that url variable, I used Scrapy’s request function to go into the actor’s page.\nIn this page, I called a third parse function.\n\n\nparse_actor_page function implementation\n\ndef parse_actor_page(self, response):\n        actor_name = response.css('div.title h2.title a::text').get()\n\n        acting_roles = response.css('div.credits_list h3.zero:contains(\"Acting\")')\n        \n        if acting_roles:\n            for acting_role in acting_roles.xpath('./following-sibling::table[@class=\"card credits\"]//table[@class=\"credit_group\"]'):\n                movie_name = acting_role.css('td.role a.tooltip bdi::text').get()\n\n                if movie_name:\n                    yield {\n                        'actor': actor_name,\n                        'movie_or_TV_name': movie_name,\n                    }\n\nI implemented this by first getting the actor’s name by using the css identifier from the website.\nNext, I sorted through only this actor’s acting roles by using the css identifier for acting roles, which was “Zero”. I iterated through all of these acting roles, and got each movie name, and yielded them into a dictionary of the actor’s name and the movies they’ve acted in."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PIC16B",
    "section": "",
    "text": "Message bank Tutorial\n\n\n\n\n\n\nweek 5\n\n\nhomework\n\n\n\n\n\n\n\n\n\nFeb 21, 2024\n\n\nAndrew Han\n\n\n\n\n\n\n\n\n\n\n\n\nHomework 2 - Scrapy\n\n\n\n\n\n\nweek 5\n\n\nhomework\n\n\n\n\n\n\n\n\n\nFeb 5, 2024\n\n\nAndrew Han\n\n\n\n\n\n\n\n\n\n\n\n\nPalmer Penguins Tutorial\n\n\n\n\n\n\nweek 3\n\n\nhomework\n\n\n\n\n\n\n\n\n\nJan 22, 2024\n\n\nAndrew Han\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJan 19, 2024\n\n\nAndrew Han\n\n\n\n\n\n\nNo matching items"
  }
]